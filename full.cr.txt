====================
FILE: FlywayConfig.java

package com.jakubbone.config;

import org.springframework.boot.autoconfigure.flyway.FlywayMigrationStrategy;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;

/**
 * Flyway migration strategy that cleans the schema before migrating.
 * Usage:
 *   - Enable only in development by activating the "dev" profile via application.properties:
 *       spring.profiles.active=dev
 *   - Or programmatically in your main application:
 *       SpringApplication app = new SpringApplication(SpringBootMailingApplication.class);
 *       app.setAdditionalProfiles("dev");
 *       app.run(args);
 *
 * WARNING: This will delete all data! Use only in dev.
 */

@Configuration
@Profile("dev") // only for development
public class FlywayConfig {
    @Bean
    public FlywayMigrationStrategy cleanMigrateStrategy() {
        return flyway -> {
            flyway.clean();    // delete entire schema and history
            flyway.migrate();  // start V1, V2â€¦
        };
    }
}

====================
FILE: SecurityConfig.java

package com.jakubbone.config;

import com.jakubbone.utils.JwtTokenFilter;
import com.jakubbone.utils.JwtTokenProvider;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

/**
 * Security configuration enabling JWT filter and method security.
 * All requests are permitted here; method-level annotations enforce roles.
 */
@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {
    private final JwtTokenProvider jwtTokenProvider;

    public SecurityConfig(JwtTokenProvider jwtTokenProvider) {
        this.jwtTokenProvider = jwtTokenProvider;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http, UserDetailsService userDetailsService) throws Exception {
        // Stateless REST API using JWT tokens only (no cookies/session)
        // CSRF protection is not needed here
        // Disable it to avoid 403 code on POST/PUT/DELETE
        http.csrf().disable()
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers(("/api/admin/v1/login/impersonation")).hasRole("ADMIN")
                        .requestMatchers(("/api/admin/v1/logout/impersonation")).hasRole("PREVIOUS_ADMINISTRATOR")
                        .requestMatchers(("/api/v1/messages")).hasAnyRole("USER", "ADMIN", "PREVIOUS_ADMINISTRATOR")
                        .requestMatchers("/api/v1/login", "/api/v1/register", "/api/v1/info", "/api/v1/uptime").permitAll()
                        .anyRequest().authenticated()
                )
                .addFilterBefore(new JwtTokenFilter(jwtTokenProvider), UsernamePasswordAuthenticationFilter.class);
        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

====================
FILE: ImpersonationController.java

package com.jakubbone.controller;

import com.jakubbone.service.ImpersonationService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.web.bind.annotation.*;

import java.util.Collections;
import java.util.Map;

@RestController
@RequestMapping("api/admin/v1")
public class ImpersonationController {
    private final ImpersonationService impersonationService;

    public ImpersonationController(ImpersonationService impersonationService) {
        this.impersonationService = impersonationService;
    }

    @PostMapping("/login/impersonation")
    public ResponseEntity<?> impersonate(@RequestParam String targetUsername, Authentication authentication){
        boolean isAdmin = authentication.getAuthorities().stream()
                        .map(GrantedAuthority::getAuthority)
                .anyMatch(a -> a.equals("ROLE_ADMIN"));

        if(!isAdmin){
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body("Admin role required");
        }

        String token = impersonationService.impersonateUser(targetUsername);
        Map<String, String> responseBody = Collections.singletonMap("token", token);
        return ResponseEntity.ok(responseBody);

    }

    @PostMapping("/logout/impersonation")
    public ResponseEntity<?> exitImpersonate(Authentication authentication){
        boolean isPreviousAdmin = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .anyMatch(a -> a.equals("ROLE_PREVIOUS_ADMINISTRATOR"));

        if(!isPreviousAdmin){
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body("Not in impersonated mode");
        }

        String token = impersonationService.exitImpersonateUser(authentication.getName());

        Map<String, String> responseBody = Collections.singletonMap("token", token);
        return ResponseEntity.ok(responseBody);
    }
}

====================
FILE: InfoController.java

package com.jakubbone.controller;

import org.springframework.beans.factory.annotation.Value;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.lang.management.ManagementFactory;
import java.util.Collections;
import java.util.Map;

@RestController
@RequestMapping("/api/v1")
public class InfoController {
    @Value("${spring.application.version}")
    private String version;

    @GetMapping("/info")
    public Map<String, String> getVersion(){
        return Collections.singletonMap("version", version);
    }

    @GetMapping("/uptime")
    public Map<String, Long> getUptime(){
        long uptimeInMillis = ManagementFactory.getRuntimeMXBean().getUptime();
        long uptimeInSeconds = uptimeInMillis / 1000;
        return Collections.singletonMap("uptime", uptimeInSeconds);
    }
}

====================
FILE: LoginController.java

package com.jakubbone.controller;

import com.jakubbone.dto.LoginRequest;
import com.jakubbone.model.User;
import com.jakubbone.repository.UserRepository;
import com.jakubbone.utils.JwtTokenProvider;
import com.jakubbone.utils.ResponseHandler;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Collections;
import java.util.Map;
import java.util.Optional;

@RestController
@RequestMapping("/api/v1")
public class LoginController {
    private final PasswordEncoder encoder;
    private final UserRepository userRepository;
    private final JwtTokenProvider jwtTokenProvider;

    public LoginController(PasswordEncoder encoder, UserRepository userRepository, JwtTokenProvider tokenProvider) {
        this.encoder = encoder;
        this.userRepository = userRepository;
        this.jwtTokenProvider = tokenProvider;
    }

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody LoginRequest req) {
        String username = req.getUsername();
        String password = req.getPassword();

        Optional<User> userOpt = userRepository.findByUsername(username);

        if (userOpt.isEmpty()){
            return ResponseHandler.error(HttpStatus.UNAUTHORIZED, "Invalid username or password");
        }

        User user = userOpt.get();

        if (!encoder.matches(password, user.getPasswordHash())){
            return ResponseHandler.error(HttpStatus.UNAUTHORIZED, "Invalid username or password");
        }

        String token = jwtTokenProvider.createToken(user.getUsername(), String.valueOf(user.getRole()));
        Map<String, String> responseBody = Collections.singletonMap("token", token);
        return ResponseEntity.ok(responseBody);
    }


}

====================
FILE: MessageController.java

package com.jakubbone.controller;

import com.jakubbone.dto.SendMessageRequest;
import com.jakubbone.model.Message;
import com.jakubbone.service.MessageService;
import com.jakubbone.utils.ResponseHandler;
import jakarta.validation.Valid;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;

@RestController
@RequestMapping("/api/v1/messages")
@PreAuthorize("hasAnyRole('ADMIN', 'USER')")
public class MessageController {
    private final MessageService messageService;

    public MessageController(MessageService messageService) {
        this.messageService = messageService;
    }

    @PostMapping
    public ResponseEntity<Map<String, Object>> sendMessage(@Valid @RequestBody SendMessageRequest req, Authentication authentication){
        String senderUsername = authentication.getName();
        Message savedMessage = messageService.sendMessage(senderUsername, req.getTo(), req.getText());
        return ResponseHandler.success(HttpStatus.CREATED, savedMessage);
    }
}

====================
FILE: LoginRequest.java

package com.jakubbone.dto;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor // @NoArgsConstructor - Jackson requires no args constructor to create JSON request
public class LoginRequest {
    private String username;
    private String password;
}

====================
FILE: SendMessageRequest.java

package com.jakubbone.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor // @NoArgsConstructor - Jackson requires no args constructor to create JSON request
public class SendMessageRequest {
    @NotBlank(message = "Recipient username cannot be blank")
    private String to;

    @NotBlank(message = "Message text cannot be blank")
    private String text;

}

====================
FILE: GlobalExceptionHandler.java

package com.jakubbone.exception;

import com.jakubbone.utils.ResponseHandler;
import io.jsonwebtoken.JwtException;
import lombok.extern.log4j.Log4j2;
import org.springframework.dao.DataAccessException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.server.ResponseStatusException;

import java.util.Map;

@ControllerAdvice
// or @RestControllerAdvice -> acts as @ControllerAdvice + @ResponseBody for all methods
@Log4j2
public class GlobalExceptionHandler {

    // Handles JWT-related exceptions (e.g. invalid or expired token)
    // HTTP Status: 401 Unauthorized
    @ExceptionHandler(JwtException.class)
    public ResponseEntity<Map<String,Object>> handleJwtException(JwtException e){
        log.error("JWT error occurred: {}", e.getMessage());
        return ResponseHandler.error(HttpStatus.UNAUTHORIZED, "Invalid JWT token");
    }

    // Handles invalid method arguments (e.g. illegal or unexpected input)
    // HTTP Status: 400 Bad Request
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<Map<String,Object>> handleIllegalArgumentException(IllegalArgumentException e){
        log.error("Illegal argument exception: {}", e.getMessage());
        return ResponseHandler.error(HttpStatus.BAD_REQUEST, "Invalid argument: " + e.getMessage());
    }

    // Handles ResponseStatusException (thrown manually with a custom HTTP status)
    // HTTP Status: Defined by exception (dynamic)
    @ExceptionHandler(ResponseStatusException.class)
    public ResponseEntity<Map<String,Object>> handleResponseStatusException(ResponseStatusException e){
        log.warn("Invalid argument provided: {}", e.getMessage());
        return ResponseHandler.error(e.getStatusCode(),  e.getReason());
    }

    // Handles database-related exceptions
    // HTTP Status: 500 Internal Server Error
    @ExceptionHandler(DataAccessException.class)
    public ResponseEntity<?> handleDataAccessException(DataAccessException e) {
        log.error("Database error occurred: {}", e.getMessage());
        return ResponseHandler.error(HttpStatus.INTERNAL_SERVER_ERROR, "Internal server error");
    }

    // Handles case when user is not found in the system (e.g. during authentication)
    // HTTP Status: 404 Not Found
    @ExceptionHandler(UsernameNotFoundException.class)
    public ResponseEntity<Map<String,Object>> handleUserNotFound(UsernameNotFoundException e) {
        log.error("User not found: {}", e.getMessage());
        return ResponseHandler.error(HttpStatus.NOT_FOUND, "User not found");
    }

    // Handles validation errors for incoming request data (e.g. @Valid fails)
    // HTTP Status: 400 Bad Request
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String,Object>> handleValidationException(MethodArgumentNotValidException e) {
        log.error("Invalid request data: {}", e.getMessage());
        return ResponseHandler.error(HttpStatus.BAD_REQUEST, "Invalid request data");
    }

    // Catches any other unhandled exceptions (generic)
    // HTTP Status: 500 Internal Server Error
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String,Object>> handleGenericException(Exception e) {
        log.error("Unexpected error occurred: {}", e.getMessage());
        return ResponseHandler.error(HttpStatus.INTERNAL_SERVER_ERROR, "Unexpected error occurred");
    }
}

====================
FILE: Message.java

package com.jakubbone.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "messages")
@Getter
@Setter
@NoArgsConstructor // JPA/Hibernate require to create object getting from DB
public class Message {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Auto-generated
    private long id;

    @ManyToOne(optional = false) // Relation to User Entity
    @JoinColumn(name = "senderId")
    private User sender;

    @ManyToOne(optional = false) // Relation to User Entity
    @JoinColumn(name = "recipientId")
    private User recipient;

    @Column(nullable = false)
    private String content;

    @Column(nullable = false)
    private LocalDateTime timestamp;
}

====================
FILE: User.java

package com.jakubbone.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "users")
@Getter
@Setter
@NoArgsConstructor // JPA/Hibernate require to create object getting from DB
public class User {

    enum Role { USER, ADMIN }

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @Column(nullable = false, unique = true)
    private String username;

    @Column(nullable = false)
    private String passwordHash;

    @Column(nullable = false)
    @Enumerated(EnumType.STRING) // Hibernate save as a String, not a number
    private Role role;

    public User(String username, String passwordHash, String role) {
        this.username = username;
        this.passwordHash = passwordHash;
        this.role = Role.valueOf(role);
    }
}

====================
FILE: MessageRepository.java

package com.jakubbone.repository;

import com.jakubbone.model.Message;
import org.springframework.data.jpa.repository.JpaRepository;

public interface MessageRepository extends JpaRepository<Message, Long> {

}

====================
FILE: UserRepository.java

package com.jakubbone.repository;

import com.jakubbone.model.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

// JPARepository provides the ready methods
// e.g. save(), findById(), findAll(), delete()
// for User Entity with the key type Long
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
}

====================
FILE: ImpersonationService.java

package com.jakubbone.service;

import com.jakubbone.model.User;
import com.jakubbone.repository.UserRepository;
import com.jakubbone.utils.JwtTokenProvider;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.server.ResponseStatusException;

@Service
public class ImpersonationService {
    private final UserRepository userRepository;
    private final JwtTokenProvider jwtTokenProvider;

    public ImpersonationService(UserRepository userRepository, JwtTokenProvider jwtTokenProvider) {
        this.userRepository = userRepository;
        this.jwtTokenProvider = jwtTokenProvider;
    }

    public String impersonateUser(String targetUsername){
        User targetUser = userRepository.findByUsername(targetUsername)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "User not found: " + targetUsername));

        return jwtTokenProvider.createImpersonationToken(targetUser.getUsername());
    }

    public String exitImpersonateUser(String adminUsername){
        User adminUser = userRepository.findByUsername(adminUsername)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Admin not found"));

        String token = jwtTokenProvider.createToken(
                adminUser.getUsername(),
                String.valueOf(adminUser.getRole())
        );
        return token;
    }
}

====================
FILE: MessageService.java

package com.jakubbone.service;

import com.jakubbone.model.Message;

public interface MessageService {
    Message sendMessage(String senderUsername, String recipientUsername, String content);
}

====================
FILE: MessageServiceImpl.java

package com.jakubbone.service;

import com.jakubbone.model.Message;
import com.jakubbone.model.User;
import com.jakubbone.repository.MessageRepository;
import com.jakubbone.repository.UserRepository;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.server.ResponseStatusException;

import java.time.LocalDateTime;

@Service
public class MessageServiceImpl implements MessageService {
    private final UserRepository userRepository;
    private final MessageRepository messageRepository;

    public MessageServiceImpl(UserRepository userRepository, MessageRepository messageRepository) {
        this.userRepository = userRepository;
        this.messageRepository = messageRepository;
    }

    @Override
    public Message sendMessage(String fromUsername, String toUsername, String content) {
        User sender = userRepository.findByUsername(fromUsername)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Sender not found"));
        User recipient = userRepository.findByUsername(toUsername)
                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Recipient not found"));

        Message msg = new Message();
        msg.setSender(sender);
        msg.setRecipient(recipient);
        msg.setContent(content);
        msg.setTimestamp(LocalDateTime.now());

        return messageRepository.save(msg);
    }
}

====================
FILE: SpringBootMailingApplication.java

package com.jakubbone;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringBootMailingApplication {
	public static void main(String[] args) {
		SpringApplication.run(SpringBootMailingApplication.class, args);
	}
}

====================
FILE: JwtTokenFilter.java

package com.jakubbone.utils;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.log4j.Log4j2;
import org.springframework.http.HttpStatus;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;

/**
 * Filter that validates JWT tokens and enforces ADMIN role.
 * Skipped for public endpoints; throws 403 if role is not ADMIN.
 */
@Component
@Log4j2
public class JwtTokenFilter extends OncePerRequestFilter {
    private final JwtTokenProvider jwtTokenProvider;

    public JwtTokenFilter(JwtTokenProvider jwtTokenProvider) {
        this.jwtTokenProvider = jwtTokenProvider;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        String authHeader = request.getHeader("Authorization");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7);
            try {
                // Token validation
                Claims claims = Jwts.parser()
                        .setSigningKey(jwtTokenProvider.getSecretKey())
                        .parseClaimsJws(token)
                        .getBody();

                String username = claims.getSubject();
                String role = claims.get("role", String.class);

                addAuthorizationToContext(username, role);

            } catch (JwtException | IllegalArgumentException ex) {
                response.sendError(HttpStatus.UNAUTHORIZED.value(), "Invalid or expired token");
                return;
            }
        }
        filterChain.doFilter(request, response);
    }

    public void addAuthorizationToContext(String username, String role) {
        // Authentication building with prefix ROLE_
        var authorities = List.of(
                new SimpleGrantedAuthority("ROLE_" + role)
        );
        var auth = new UsernamePasswordAuthenticationToken(
                username, null, authorities
        );

        // Add auth to Security Context to authorize request
        SecurityContextHolder.getContext().setAuthentication(auth);
    }
}

====================
FILE: JwtTokenProvider.java

package com.jakubbone.utils;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import lombok.Getter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.Date;

@Component
@Getter
public class JwtTokenProvider {
    @Value("${jwt.secret}")
    private String secretKey;

    @Value("${jwt.expiration}")
    private long expirationMillis;

    public String createToken(String username, String role){
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expirationMillis);

        return Jwts.builder()
                .setSubject(username)
                .claim("role", role)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(SignatureAlgorithm.HS512, secretKey)
                .compact();
    }

    public String createImpersonationToken(String targetUsername){
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + expirationMillis);

        return Jwts.builder()
                .setSubject(targetUsername)
                .claim("role", "PREVIOUS_ADMINISTRATOR")
                .claim("isImpersonated", true)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(SignatureAlgorithm.HS512, secretKey)
                .compact();
    }

}

====================
FILE: ResponseHandler.java

package com.jakubbone.utils;

import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;

import java.time.Instant;
import java.util.Map;

public class ResponseHandler {

    // envelope for status OK (200)
    public static ResponseEntity<Map<String,Object>> success(Object data) {
        Map<String,Object> body = Map.of(
                "timestamp", Instant.now().toString(),
                "statusCode", HttpStatus.OK.value(),
                "data", data
        );
        return ResponseEntity.ok(body);
    }

    // envelope for another status (e.g. CREATED)
    public static ResponseEntity<Map<String,Object>> success(HttpStatus status, Object data) {
        Map<String,Object> body = Map.of(
                "timestamp", Instant.now().toString(),
                "statusCode",    status.value(),
                "status",    status.getReasonPhrase(),
                "data",      data
        );
        return ResponseEntity.status(status).body(body);
    }

    // envelope for error (HttpStatus)
    public static ResponseEntity<Map<String,Object>> error(HttpStatus status, String message) {
        Map<String,Object> body = Map.of(
                "timestamp", Instant.now().toString(),
                "errorCode", status.value(),
                "error", status.getReasonPhrase(),
                "message", message
        );
        return ResponseEntity.status(status).body(body);
    }

    // envelope for error (HttpStatusCode)
    public static ResponseEntity<Map<String, Object>> error(HttpStatusCode statusCode, String message) {
        Map<String,Object> body = Map.of(
                "timestamp", Instant.now().toString(),
                "errorCode", statusCode.value(),
                "message", message
        );
        return ResponseEntity.status(statusCode).body(body);
    }
}

====================
FILE: ImpersonationControllerTest.java

package com.jakubbone.integration;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.jakubbone.model.User;
import com.jakubbone.repository.UserRepository;
import com.jakubbone.utils.JwtTokenProvider;
import org.junit.jupiter.api.BeforeEach;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.result.MockMvcResultHandlers;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@ActiveProfiles("test")
@SpringBootTest
@AutoConfigureMockMvc
class ImpersonationControllerTest {
    @Autowired
    ObjectMapper mapper;

    @Autowired
    UserRepository userRepository;

    @Autowired
    PasswordEncoder passwordEncoder;

    @Autowired
    JwtTokenProvider jwtTokenProvider;

    String adminToken;
    String impersonatedAdminToken;

    String userToken;

    @BeforeEach
    void setup() {
        mapper = new ObjectMapper();
        userRepository.deleteAll();
        User testUser = new User("testUser", passwordEncoder.encode("testPassword"), "USER");
        User testAdmin = new User("testAdmin", passwordEncoder.encode("testPassword"), "ADMIN");
        userRepository.save(testUser);
        userRepository.save(testAdmin);
        adminToken = jwtTokenProvider.createToken("testAdmin", "ADMIN");
        impersonatedAdminToken = jwtTokenProvider.createImpersonationToken("testUser");
        userToken = jwtTokenProvider.createToken("testUser", "USER");
    }

    // LOGIN IMPERSONATION TESTS

    @Test
    void shouldReturnOk_ImpersonationLogin_WhenAuthorized(@Autowired MockMvc mockMvc) throws Exception {
        mockMvc.perform(post("/api/admin/v1/login/impersonation")
                    .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                    .contentType(MediaType.APPLICATION_FORM_URLENCODED_VALUE)
                    .param("targetUsername", "testUser"))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isOk());
    }

    @Test
    void shouldReturn403__ImpersonationLogin_WhenNotAdmin(@Autowired MockMvc mockMvc) throws Exception {
        mockMvc.perform(post("/api/admin/v1/login/impersonation")
                    .header(HttpHeaders.AUTHORIZATION, "Bearer " + userToken)
                    .contentType(MediaType.APPLICATION_FORM_URLENCODED_VALUE)
                    .param("targetUsername", "adminUser"))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isForbidden());
    }

    @Test
    void shouldReturn403_ImpersonationLogin_WhenTargetUserNotFound(@Autowired MockMvc mockMvc) throws Exception {
        mockMvc.perform(post("/api/admin/v1/login/impersonation")
                    .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                    .contentType(MediaType.APPLICATION_FORM_URLENCODED_VALUE)
                    .param("targetUsername", "anotherUser"))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isNotFound());
    }

    @Test
    void shouldReturn500_ImpersonationLogin_WhenNoParams(@Autowired MockMvc mockMvc) throws Exception {
        mockMvc.perform(post("/api/admin/v1/login/impersonation")
                    .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                    .contentType(MediaType.APPLICATION_FORM_URLENCODED_VALUE))
                // without targetUser param
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().is5xxServerError());
    }

    @Test
    void shouldReturn500_ImpersonationLogin_WhenNoToken(@Autowired MockMvc mockMvc) throws Exception {
        mockMvc.perform(post("/api/admin/v1/login/impersonation")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer ")
                        .contentType(MediaType.APPLICATION_FORM_URLENCODED_VALUE)
                        .param("targetUsername", "testUser"))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isUnauthorized());
    }

    // LOGOUT IMPERSONATION TESTS

    @Test
    void shouldReturnOk_ImpersonationLogout_WhenAuthorized(@Autowired MockMvc mockMvc) throws Exception {
        mockMvc.perform(post("/api/admin/v1/logout/impersonation")
                    .header(HttpHeaders.AUTHORIZATION, "Bearer " + impersonatedAdminToken)
                    .contentType(MediaType.APPLICATION_JSON))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isOk());
    }


    @Test
    void shouldReturn500_ImpersonationLogout_WhenInvalidToken(@Autowired MockMvc mockMvc) throws Exception {
        mockMvc.perform(post("/api/admin/v1/login/impersonation")
                    .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                    .contentType(MediaType.APPLICATION_FORM_URLENCODED_VALUE))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().is5xxServerError());
    }

    @Test
    void shouldReturn500_ImpersonationLogout_WhenNoToken(@Autowired MockMvc mockMvc) throws Exception {
        mockMvc.perform(post("/api/admin/v1/login/impersonation")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer ")
                        .contentType(MediaType.APPLICATION_JSON))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isUnauthorized());
    }
}

====================
FILE: InfoControllerTest.java

package com.jakubbone.integration;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;
import org.springframework.test.web.servlet.result.MockMvcResultHandlers;
import org.springframework.test.web.servlet.result.MockMvcResultMatchers;

import static org.hamcrest.Matchers.greaterThanOrEqualTo;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;

@ActiveProfiles("test")
@SpringBootTest
@AutoConfigureMockMvc
class InfoControllerTest {
	@Test
	void shouldReturnApplicationVersion(@Autowired MockMvc mockMvc) throws Exception {
		mockMvc.perform(MockMvcRequestBuilders.get("/api/v1/info"))
				.andDo(MockMvcResultHandlers.print())
				.andExpect(MockMvcResultMatchers.status().isOk())
				.andExpect(MockMvcResultMatchers.content().contentType(
						"application/json"))
				.andExpect(jsonPath("$.version").isString());
	}

	@Test
	void shouldReturnApplicationUptime(@Autowired MockMvc mockMvc) throws Exception {
		mockMvc.perform(MockMvcRequestBuilders.get("/api/v1/uptime"))
				.andDo(MockMvcResultHandlers.print())
				.andExpect(MockMvcResultMatchers.status().isOk())
				.andExpect(MockMvcResultMatchers.content().contentType(
						"application/json"))
				.andExpect(jsonPath("$.uptime").isNumber())
				.andExpect(jsonPath("$.uptime", greaterThanOrEqualTo(0)));
	}
}

====================
FILE: LoginControllerTest.java

package com.jakubbone.integration;

import com.fasterxml.jackson.databind.ObjectMapper;

import com.jakubbone.dto.LoginRequest;
import com.jakubbone.model.User;
import com.jakubbone.repository.UserRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.result.MockMvcResultHandlers;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;

import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;



@ActiveProfiles("test") // set h2 profile; test uses application-test.properties
@SpringBootTest // @SpringBootTest runs all components with all Spring configuration
@AutoConfigureMockMvc // MockMvc injection for HTTP requests sending without server running
class LoginControllerTest {
    @Autowired
    ObjectMapper mapper;

    @Autowired
    UserRepository userRepository;

    @Autowired
    PasswordEncoder passwordEncoder;

    @BeforeEach
    void setup() {
        userRepository.deleteAll();
        User testUser = new User("testUser", passwordEncoder.encode("testPassword"), "USER");
        userRepository.save(testUser);
    }

    @Test
    void shouldReturn401_whenPasswordIncorrect(@Autowired MockMvc mockMvc) throws Exception {
        LoginRequest req = new LoginRequest("testUser","incorrectPassword" );

        mockMvc.perform(post("/api/v1/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isUnauthorized());
    }

    @Test
    void shouldReturn401_whenUsernameIncorrect(@Autowired MockMvc mockMvc) throws Exception {
        LoginRequest req = new LoginRequest("incorrectUsername", "testPassword" );

        mockMvc.perform(post("/api/v1/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isUnauthorized());
    }

    @Test
    void shouldReturnOk_whenCredentialsCorrect(@Autowired MockMvc mockMvc) throws Exception {
        LoginRequest req = new LoginRequest("testUser", "testPassword");

        mockMvc.perform(post("/api/v1/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isOk());
    }

    @Test
    void shouldReturnToken_whenCredentialsCorrect(@Autowired MockMvc mockMvc) throws Exception {
        LoginRequest req = new LoginRequest("testUser", "testPassword");

        mockMvc.perform(post("/api/v1/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.token").exists());
    }
}

====================
FILE: MessageControllerTest.java

package com.jakubbone.integration;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.jakubbone.dto.SendMessageRequest;
import com.jakubbone.model.User;
import com.jakubbone.repository.MessageRepository;
import com.jakubbone.repository.UserRepository;
import com.jakubbone.utils.JwtTokenProvider;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.result.MockMvcResultHandlers;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;


@ActiveProfiles("test")
@SpringBootTest
@AutoConfigureMockMvc
class MessageControllerTest {
    @Autowired
    ObjectMapper mapper;

    @Autowired
    UserRepository userRepository;

    @Autowired
    MessageRepository messageRepository;

    @Autowired
    PasswordEncoder passwordEncoder;

    @Autowired
    JwtTokenProvider jwtTokenProvider;

    String adminToken;
    String userToken;

    @BeforeEach
    void setup() {
        messageRepository.deleteAll();
        userRepository.deleteAll();
        User testUser = new User("testUser", passwordEncoder.encode("testPassword"), "USER");
        User testAdmin = new User("testAdmin", passwordEncoder.encode("testPassword"), "ADMIN");
        userRepository.save(testUser);
        userRepository.save(testAdmin);
        userToken = jwtTokenProvider.createToken(testUser.getUsername(), String.valueOf(testUser.getRole()));
        adminToken = jwtTokenProvider.createToken(testAdmin.getUsername(), String.valueOf(testAdmin.getRole()));
    }

    @Test
    void shouldReturn201_whenAdminValidToken(@Autowired MockMvc mockMvc) throws Exception {
        SendMessageRequest req = new SendMessageRequest("testUser", "Hello user!");
        mockMvc.perform(post("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.data.id").exists())
                .andExpect(jsonPath("$.data.sender.username").value("testAdmin"))
                .andExpect(jsonPath("$.data.recipient.username").value("testUser"))
                .andExpect(jsonPath("$.data.content").value("Hello user!"));
    }


    @Test
    void shouldReturn401_whenUserValidToken(@Autowired MockMvc mockMvc) throws Exception {
        SendMessageRequest req = new SendMessageRequest("testAdmin", "Hello admin!");
        mockMvc.perform(post("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + userToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.data.id").exists())
                .andExpect(jsonPath("$.data.sender.username").value("testUser"))
                .andExpect(jsonPath("$.data.recipient.username").value("testAdmin"))
                .andExpect(jsonPath("$.data.content").value("Hello admin!"));

    }

    @Test
    void shouldReturn404_whenRecipientNotFound(@Autowired MockMvc mockMvc) throws Exception {
        SendMessageRequest req = new SendMessageRequest("unknown", "Hello unknown!");

        mockMvc.perform(post("/api/v1/messages")
                    .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isNotFound());

    }

    @Test
    void shouldReturn404_whenNoContent(@Autowired MockMvc mockMvc) throws Exception {
        SendMessageRequest req = new SendMessageRequest("testUser", "");

        mockMvc.perform(post("/api/v1/messages")
                    .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isBadRequest());
    }
}

====================
FILE: ImpersonationControllerTest.java

package com.jakubbone.unit;

import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

@ActiveProfiles("test")
@SpringBootTest
@AutoConfigureMockMvc
public class ImpersonationControllerTest {

}

====================
FILE: LoginControllerTest.java

package com.jakubbone.unit;

import com.jakubbone.controller.LoginController;
import com.jakubbone.dto.LoginRequest;
import com.jakubbone.model.User;
import com.jakubbone.repository.UserRepository;
import com.jakubbone.utils.JwtTokenProvider;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.util.Map;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class LoginControllerTest {

    @InjectMocks
    LoginController loginController;

    @Mock
    UserRepository userRepository;

    @Mock
    PasswordEncoder passwordEncoder;

    @Mock
    JwtTokenProvider jwtTokenProvider;

    @Test
    void shouldReturnToken_whenLoginSuccess_ReturnsToken() {
        LoginRequest req = new LoginRequest("alice", "password123");
        User user = new User("alice", "testHashedPassword", "USER");

        when(userRepository.findByUsername("alice")).thenReturn(Optional.of(user));
        when(passwordEncoder.matches("password123", user.getPasswordHash())).thenReturn(true);
        when(jwtTokenProvider.createToken("alice", "USER")).thenReturn("fake-jwt-token");

        ResponseEntity <?> resp = loginController.login(req);
        Map respBody = (Map) resp.getBody();

        assertEquals(HttpStatus.OK, resp.getStatusCode());
        assertEquals("fake-jwt-token", respBody.get("token"));
    }

    @Test
    void shouldReturn401_whenPasswordIncorrect() {
        LoginRequest req = new LoginRequest("alice", "incorrectPassword");
        User user = new User("alice", "testHashedPassword", "USER");

        when(userRepository.findByUsername("alice")).thenReturn(Optional.of(user));
        when(passwordEncoder.matches("incorrectPassword", user.getPasswordHash())).thenReturn(false);

        ResponseEntity <?> resp = loginController.login(req);

        assertEquals(HttpStatus.UNAUTHORIZED, resp.getStatusCode());
    }

    @Test
    void shouldReturn401_whenUserIncorrect() {
        LoginRequest req = new LoginRequest("incorrectUser", "password123");
        User user = new User("incorrectUser", "password123", "USER");

        when(userRepository.findByUsername("incorrectUser")).thenReturn(Optional.empty());

        ResponseEntity <?> resp = loginController.login(req);

        assertEquals(HttpStatus.UNAUTHORIZED, resp.getStatusCode());
    }
}

