====================
FILE: FlywayConfig.java

package com.jakubbone.config;

import org.springframework.boot.autoconfigure.flyway.FlywayMigrationStrategy;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;

/**
 * Development-only Flyway migration strategy that cleans the database schema before migrating.
 * This configuration is only active when the 'dev' profile is enabled.
 * To enable the 'dev' profile, set the environment variable SPRING_PROFILES_ACTIVE=dev.
 *
 * WARNING: This is a destructive operation that will delete all data in the database.
 * It is strictly for use in local development environments.
 */
@Configuration
@Profile("dev")
public class FlywayConfig {
    @Bean
    public FlywayMigrationStrategy cleanMigrateStrategy() {
        return flyway -> {
            flyway.clean();
            flyway.migrate();
        };
    }
}

====================
FILE: KeycloakConfig.java

package com.jakubbone.config;

import org.keycloak.OAuth2Constants;
import org.keycloak.admin.client.Keycloak;
import org.keycloak.admin.client.KeycloakBuilder;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Configuration of the Keycloak client for connecting to the Keycloak server
 * to manage users and authorization
 */
@Configuration
public class KeycloakConfig {
    @Value("${keycloak.base-url}")
    private String keycloakBaseUrl;

    @Value("${keycloak.realm}")
    private String keycloakRealm;

    @Value("${keycloak.admin-client-id}")
    private String adminClientId;

    @Value("${keycloak.admin-client-secret}")
    private String adminClientSecret;

    /**
     * Creates and configures the Keycloak admin client bean
     * which is used to communicate with the Keycloak server
     *
     * @return configured Keycloak client
     */
    @Bean
    public Keycloak keycloak() {
        return KeycloakBuilder.builder()
                .serverUrl(keycloakBaseUrl)
                .realm(keycloakRealm)
                .clientId(adminClientId)
                .clientSecret(adminClientSecret)
                .grantType(OAuth2Constants.CLIENT_CREDENTIALS)
                .build();
    }
}

====================
FILE: OpenApiConfig.java

package com.jakubbone.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.security.OAuthFlow;
import io.swagger.v3.oas.models.security.OAuthFlows;
import io.swagger.v3.oas.models.security.Scopes;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        String tokenUrl = "http://localhost:8180/realms/mailingsystem/protocol/openid-connect/token";

        return new OpenAPI()
                .info(new Info()
                        .title("Spring Boot Mailing System API")
                        .version("1.0.0")
                        .description("""
                            RESTful API for a messaging system with OAuth2 authentication via Keycloak.
                            
                            ## Quick Start - Testing the API
                            
                            ## Testing Flow Example
                            
                            **Scenario 1: With new user registration**
                            1. Register new user "johndoe": POST /api/v1/auth/register
                            2. Authorize as "johndoe"
                            3. Send message to "adminuser"
                            4. Logout
                            5. Authorize as "adminuser"
                            6. Read messages from "johndoe"
                            7. Reply to "johndoe"
                            
                            **Scenario 2: Using pre-configured users**
                            1. Authorize as "adminuser" with password "java10"
                            2. Send message "hello user!" to "testuser": POST /api/v1/messages
                            3. Logout 
                            4. Authorize as "testuser" with password "java10"
                            5. Read messages: GET /api/v1/messages
                            6. Search messages: GET /api/v1/messages/search?phrase=hello
                            
                            Any registered user can communicate with any other user in the system

                            **Important:** You must register a user BEFORE you can authorize as that user.

                            ## Test Users
                            
                            **Pre-configured accounts:**
                            - **testuser** / userPassword = "java10"
                            - **adminuser**/ userPassword = "java10"
                            
                            ## Features
                            
                            - User registration and authentication
                            - Send and receive messages between users
                            - Full-text search in message content
                            - Automatic message read status tracking
                            - Role-based access control (USER, ADMIN)
                            - Input validation and XSS protection
                            
                            ## Validation Rules
                            
                            - **Username:** 3-10 letters only
                            - **Password:** Minimum 8 characters
                            - **Message:** 1-256 characters, HTML sanitized
                            - **Mailbox limit:** 5 unread messages per user

                            ## Token Expiration
                            
                            JWT tokens expire after 5 minutes (300 seconds). 
                            If you receive 401 errors, re-authenticate to obtain a new token.
                            
                            ## Error Responses
                            
                            - **400** Bad Request - Validation failed
                            - **401** Unauthorized - Authentication required
                            - **403** Forbidden - Insufficient permissions
                            - **404** Not Found - Resource does not exist
                            - **409** Conflict - Business rule violation (e.g., mailbox full)
                            - **500** Internal Server Error - Unexpected error
                            """))
                .addSecurityItem(new SecurityRequirement().addList("keycloak_oauth"))
                .components(new Components()
                        .addSecuritySchemes("keycloak_oauth",
                                new SecurityScheme()
                                        .type(SecurityScheme.Type.OAUTH2)
                                        .description("""
                                            OAuth 2.0 Password Grant flow with Keycloak.
                                            
                                            Tokens are valid for 5 minutes and must be included 
                                            in the Authorization header as: Bearer <token>
                                            """)
                                        .flows(new OAuthFlows()
                                                .password(new OAuthFlow()
                                                        .tokenUrl(tokenUrl)
                                                        .scopes(new Scopes()
                                                                .addString("openid", "OpenID Connect authentication")
                                                                .addString("profile", "User profile information")
                                                                .addString("email", "User email address"))))));
    }
}

====================
FILE: RestTamplateConfig.java

package com.jakubbone.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.client.RestTemplate;

/**
 * Configuration for RestTemplate bean used for HTTP client operations.
 * RestTemplate is used primarily for communicating with Keycloak token endpoint.
 */
@Configuration
public class RestTamplateConfig {
    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}

====================
FILE: SecurityConfig.java

package com.jakubbone.config;

import com.jakubbone.utils.KeycloakRoleConverter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        // Stateless REST API using JWT tokens only (no cookies/session)
        // CSRF protection disabled to avoid 403 errors on state-changing requests
        http.csrf().disable()
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authorizeHttpRequests(auth -> auth
                        // Swagger UI endpoints - public access
                        .requestMatchers(
                                "/v3/api-docs/**",
                                "/swagger-ui/**",
                                "/swagger-ui.html"
                        ).permitAll()
                        // Authorization endpoints
                        .requestMatchers("/api/v1/auth/**").permitAll()
                        // Actuator endpoints
                        .requestMatchers("/actuator/health", "/actuator/info").permitAll()
                        .requestMatchers("/actuator/**").hasRole("ADMIN")
                        // API endpoints
                        .requestMatchers(("/api/v1/messages/**")).hasAnyRole("USER", "ADMIN")
                        .anyRequest().authenticated()
                )
                .oauth2ResourceServer(oauth2 -> oauth2
                        .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter()))
                );
        return http.build();
    }

    /**
     * Converts JWT token extracting roles from Keycloak into Spring Security authorities
     */
    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
        converter.setJwtGrantedAuthoritiesConverter(new KeycloakRoleConverter());
        return converter;
    }
}

====================
FILE: AuthController.java

package com.jakubbone.controller;

import com.jakubbone.dto.LoginRequest;
import com.jakubbone.dto.RegisterRequest;
import com.jakubbone.dto.TokenResponse;
import com.jakubbone.service.AuthService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Authentication controller for user registration and login.
 * Handles user management in Keycloak and JWT token generation.
 */
@Tag(name = "Authentication", description = "User registration and login endpoints")
@RestController
@RequestMapping("api/v1/auth")
public class AuthController {
    private final AuthService authService;

    public AuthController(AuthService authService) {
        this.authService = authService;
    }

    @Operation(
            summary = "Register a new user",
            description = "Creates a new user account in the system",
            responses = {
                    @ApiResponse(responseCode = "201", description = "User successfully registered"),
                    @ApiResponse(responseCode = "409", description = "User already exists")
            }
    )
    @PostMapping("/register")
    public ResponseEntity<String> register(@Valid @RequestBody RegisterRequest req){
        authService.registerUser(req.getUsername(),
                req.getPassword(),
                req.getEmail(),
                req.getFirstName(),
                req.getLastName());
        return ResponseEntity.status(HttpStatus.CREATED)
                .body("User registered successfully. You can now login.");
    }

    @Operation(
            summary = "User login",
            description = "Authenticates user and generates JWT token",
            responses = {
                    @ApiResponse(responseCode = "201", description = "JWT token response Json"),
                    @ApiResponse(responseCode = "401", description = "Invalid username or password")
            }
    )
    @PostMapping("/login")
    public ResponseEntity<TokenResponse> login(@Valid @RequestBody LoginRequest req){
        TokenResponse response = authService.loginUser(req.getUsername(), req.getPassword());
        return ResponseEntity.ok(response);
    }
}

====================
FILE: MessageController.java

package com.jakubbone.controller;

import com.jakubbone.dto.ErrorResponse;
import com.jakubbone.dto.MessageResponse;
import com.jakubbone.dto.SendMessageRequest;
import com.jakubbone.model.Message;
import com.jakubbone.service.MessageService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springdoc.core.annotations.ParameterObject;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.core.Authentication;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.web.bind.annotation.*;

@Tag( name = "Messages", description = "Send, read and search message operations")
@RestController
@RequestMapping("/api/v1/messages")
public class MessageController {
    private final MessageService messageService;

    public MessageController(MessageService messageService) {
        this.messageService = messageService;
    }

    /**
     * Sends a message to another user.
     *
     * @param req the message request containing recipient and content
     * @param authentication the authenticated user sending the message
     * @return the created message with HTTP 201 status
     * @throws ResponseStatusException if recipient not found (404) or mailbox full (409)
     */
    @Operation(
            summary = "Send message",
            description = "Sends messages to another user",
            responses = {
                    @ApiResponse(
                            responseCode = "201",
                            description = "Message sent successfully",
                            content = @Content(
                                    mediaType = "application/json",
                                    schema = @Schema(implementation = MessageResponse.class)
                            )
                    ),
                    @ApiResponse(
                            responseCode = "404",
                            description = "Recipient not found",
                            content = @Content(
                                    mediaType = "application/json",
                                    schema = @Schema(implementation = ErrorResponse.class)
                            )
                    ),
                    @ApiResponse(
                            responseCode = "409",
                            description = "Users mailbox is full",
                            content = @Content(
                                    mediaType = "application/json",
                                    schema = @Schema(implementation = ErrorResponse.class)
                            )
                    ),
                    @ApiResponse(
                            responseCode = "401",
                            description = "Unauthorized - Missing or invalid JWT token"
                    )
            }
    )
    @PostMapping
    public ResponseEntity<MessageResponse> sendMessage(
            @Valid @RequestBody SendMessageRequest req,
            Authentication authentication){

        JwtAuthenticationToken jwt = (JwtAuthenticationToken) authentication;
        String sender = jwt.getToken().getClaim("preferred_username");

        Message savedMsg = messageService.send(sender, req.getTo(), req.getText());
        MessageResponse response = MessageResponse.fromEntity(savedMsg);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    /**
     * Retrieves paginated messages for the authenticated user and marks them as read.
     *
     * @param authentication the authenticated user
     * @param pageable pagination parameters (page, size, sort)
     * @return page of messages with HTTP 200 status
     */

    @Operation(
            summary = "Read messages",
            description = "Get message from logged user",
            responses = {
                    @ApiResponse(
                            responseCode = "200",
                            description = "Return page of messages",
                            content = @Content(
                                    mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class)
                            )
                    ),
                    @ApiResponse(
                            responseCode = "401",
                            description = "Unauthorized - Missing or invalid JWT token"
                    )
            }
    )
   @GetMapping
   public ResponseEntity<Page<MessageResponse>> readMessages(
           Authentication authentication,
           @ParameterObject Pageable pageable) {

        JwtAuthenticationToken jwt = (JwtAuthenticationToken) authentication;
        String recipient = jwt.getToken().getClaim("preferred_username");

        Page<MessageResponse> messages = messageService.readAndMarkAsRead(recipient, pageable).map(MessageResponse::fromEntity);
        return ResponseEntity.ok(messages);
    }

    /**
     * Marks a specific message as read.
     *
     * @param id the message ID
     * @param authentication the authenticated user (must be the recipient)
     * @return HTTP 204 No Content on success
     * @throws ResponseStatusException if message not found (404) or access denied (403)
     */

    @Operation(
            summary = "Mark message as read",
            description = "Marks a specific message as read",
            responses = {
                    @ApiResponse(
                            responseCode = "204",
                            description = "Message read"
                    ),
                    @ApiResponse(
                            responseCode = "403",
                            description = "Access denied",
                            content = @Content(
                                    mediaType = "application/json",
                                    schema = @Schema(implementation = ErrorResponse.class)
                            )
                    ),
                    @ApiResponse(
                            responseCode = "404",
                            description = "Message not found",
                            content = @Content(
                                    mediaType = "application/json",
                                    schema = @Schema(implementation = ErrorResponse.class)
                            )
                    ),
                    @ApiResponse(
                            responseCode = "401",
                            description = "Unauthorized - Missing or invalid JWT token"
                    )
            }
    )
    @PatchMapping("/{id}/read")
    public ResponseEntity<Void> markMessageAsRead(@PathVariable Long id, Authentication authentication) {
        JwtAuthenticationToken jwt = (JwtAuthenticationToken) authentication;
        String recipient = jwt.getToken().getClaim("preferred_username");

        messageService.markAsRead(id, recipient);
        return ResponseEntity.noContent().build();
    }

    /**
     * Searches messages by phrase using PostgreSQL full-text search.
     *
     * @param phrase the search query (minimum 2 characters)
     * @param authentication the authenticated user
     * @param pageable pagination parameters
     * @return page of matching messages with HTTP 200 status
     * @throws ResponseStatusException if phrase too short (400)
     */

    @Operation(
            summary = "Search messages",
            description = "Searches messages by phrase",
            responses = {
                    @ApiResponse(
                            responseCode = "200",
                            description = "Message found successfully",
                            content = @Content(
                                    mediaType = "application/json",
                                    schema = @Schema(implementation = Page.class)
                            )
                    ),
                    @ApiResponse(
                            responseCode = "400",
                            description = "Phrase too short",
                            content = @Content(
                                    mediaType = "application/json",
                                    schema = @Schema(implementation = ErrorResponse.class)
                            )
                    ),
                    @ApiResponse(
                            responseCode = "401",
                            description = "Unauthorized - Missing or invalid JWT token"
                    )
            }
    )
    @GetMapping("/search")
    public ResponseEntity<Page<MessageResponse>> searchMessages(
            @RequestParam String phrase,
            Authentication authentication,
            @ParameterObject Pageable pageable){

        JwtAuthenticationToken jwt = (JwtAuthenticationToken) authentication;
        String username = jwt.getToken().getClaim("preferred_username");

        Page<MessageResponse> messages = messageService.searchMessages(username, phrase, pageable)
                .map(MessageResponse::fromEntity);
        return ResponseEntity.ok(messages);
    }
}

====================
FILE: ErrorResponse.java

package com.jakubbone.dto;

import io.swagger.v3.oas.annotations.media.Schema;

@Schema(description = "Specific error response structure")
public record ErrorResponse(
        @Schema(description = "Error signature", example = "2025-01-15T10:30:45Z")
        String timestamp,

        @Schema(description = "HTTP error code", example = "400")
        int errorCode,

        @Schema(description = "Short error description", example = "Bad Request")
        String error,

        @Schema(description = "Extended error description")
        String message) {
}

====================
FILE: LoginRequest.java

package com.jakubbone.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Schema(description = "User login details")
public class LoginRequest {
    @Schema(description = "Username", example = "johndoe")
    @NotBlank(message = "Username cannot be blank")
    private String username;

    @Schema(description = "Password", example = "Password123!")
    @NotBlank(message = "Password cannot be blank")
    private String password;
}

====================
FILE: MessageResponse.java

package com.jakubbone.dto;

import com.jakubbone.model.Message;
import io.swagger.v3.oas.annotations.media.Schema;

import java.time.LocalDateTime;

@Schema(description = "Message details response")
public record MessageResponse(
        @Schema(
                description = "Unique message id",
                example = "1",
                minimum = "1"
        )
        Long id,

        @Schema(
                description = "Sender username",
                example = "johndoe"
        )
        String senderUsername,

        @Schema(
                description = "Recipient username",
                example = "johndoe"
        )
        String recipientUsername,

        @Schema(
                description = "Message content",
                example = "Hello user!",
                maxLength = 256
        )
        String content,

        @Schema(
                description = "Date and time of message sending",
                example = "2024-01-15T10:30:45"
        )
        LocalDateTime timestamp,

        @Schema(
                description = "Flag describing whether message is read",
                example = "false"
        )
        boolean isRead
) {
    public static MessageResponse fromEntity(Message msg) {
        return new MessageResponse(
                msg.getId(),
                msg.getSenderId(),
                msg.getRecipientId(),
                msg.getContent(),
                msg.getTimestamp(),
                msg.isRead()
        );
    }
}

====================
FILE: RegisterRequest.java

package com.jakubbone.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Schema(description = "A new user registration data")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class RegisterRequest {
    @Schema(
            description = "Username",
            example = "johndoe",
            minLength = 3,
            maxLength = 10
    )
    @NotBlank(message = "Username cannot be blank")
    @Size(min = 3, max = 10, message = "Username must be between 3 and 10 characters long")
    @Pattern(regexp = "^[A-Za-z]{3,10}$",
            message = "Username must contain only letters (A–Z), length 3–10")
    private String username;

    @Schema(
            description = "Password",
            minLength = 8,
            example = "Password123!"
    )
    @NotBlank(message = "Password cannot be blank")
    @Size(min = 8, message = "Password must be at least 8 characters")
    private String password;


    @Schema(
            description = "Email address",
            example = "username@spring.com"
    )
    @NotBlank(message = "Email cannot be blank")
    private String email;

    @Schema(
            description = "Users first name",
            example = "John"
    )
    @NotBlank(message = "Users first name")
    private String firstName;

    @Schema(
            description = "Users last name",
            example = "Doe"
    )
    @NotBlank(message = "Last name cannot be blank")
    private String lastName;
}

====================
FILE: SendMessageRequest.java

package com.jakubbone.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Schema(description = "Message specific message to send data")
public class SendMessageRequest {
    @Schema(
            description = "Recipient username",
            example = "johndoe",
            minLength = 3,
            maxLength = 10
    )
    @NotBlank(message = "Recipient username cannot be blank")
    @Size(min = 3, max = 10, message = "Username must be between 3 and 10 characters long")
    @Pattern(regexp = "^[A-Za-z]{3,10}$",
            message = "Username must contain only letters (A–Z), length 3–10")
    private String to;

    @Schema(
            description = "Message content",
            example = "Hello user!",
            minLength = 1,
            maxLength = 256
    )
    @NotBlank(message = "Message text cannot be blank")
    @Size(min = 1, max = 256, message = "Message text must be between 1 and 256 characters long")
    private String text;
}

====================
FILE: TokenResponse.java

package com.jakubbone.dto;

import io.swagger.v3.oas.annotations.media.Schema;

@Schema(description = "Response containing access token")
public record TokenResponse(
        @Schema(description = "JWT access token", example = "eyJhbGciOiJIUzI1...")
        String accessToken,

        @Schema(description = "JWT token expire time", example = "360")
        Integer expireTime,

        @Schema(description = "JWT token Type", example = "Bearer")
        String tokenType) {
}

====================
FILE: GlobalExceptionHandler.java

package com.jakubbone.exception;

import com.jakubbone.dto.ErrorResponse;
import io.jsonwebtoken.JwtException;
import lombok.extern.log4j.Log4j2;
import org.springframework.dao.DataAccessException;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.server.ResponseStatusException;

import java.time.Instant;

import static org.springframework.http.HttpStatus.*;


@ControllerAdvice
@Log4j2
public class GlobalExceptionHandler {

    /**
     * Handles JWT-related exceptions such as invalid or expired tokens.
     *
     * @param e the JWT exception
     * @return error response with HTTP 401 Unauthorized
     */
    @ExceptionHandler(JwtException.class)
    public ResponseEntity<ErrorResponse> handleJwtException(JwtException e){
        log.error("JWT error occurred: {}", e.getMessage());
        ErrorResponse error = new ErrorResponse(
                Instant.now().toString(),
                UNAUTHORIZED.value(),
                UNAUTHORIZED.getReasonPhrase(),
                "Invalid JWT token"
        );
        return ResponseEntity.status(UNAUTHORIZED).body(error);
    }

    /**
     * Handles illegal method arguments.
     *
     * @param e the illegal argument exception
     * @return error response with HTTP 400 Bad Request
     */
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponse> handleIllegalArgumentException(IllegalArgumentException e){
        log.error("Illegal argument exception: {}", e.getMessage());
        ErrorResponse error = new ErrorResponse(
                Instant.now().toString(),
                BAD_REQUEST.value(),
                BAD_REQUEST.getReasonPhrase(),
                "Invalid argument"
        );
        return ResponseEntity.status(BAD_REQUEST).body(error);
    }

    /**
     * Handles custom exceptions thrown with specific HTTP status codes.
     *
     * @param e the response status exception
     * @return error response with the HTTP status from the exception
     */
    @ExceptionHandler(ResponseStatusException.class)
    public ResponseEntity<ErrorResponse> handleResponseStatusException(ResponseStatusException e){
        log.warn("Unexpected error occurred: {}", e.getMessage());

        String reason = switch (e.getStatusCode()) {
            case NOT_FOUND     -> "Resource not available";
            case CONFLICT      -> "Request conflict";
            case BAD_REQUEST   -> "Invalid request";
            default            -> "Request failed";
        };

        ErrorResponse error = new ErrorResponse(
                Instant.now().toString(),
                e.getStatusCode().value(),
                e.getStatusCode().toString(),
                e.getReason() != null ? e.getReason() : reason
        );
        return ResponseEntity.status(e.getStatusCode()).body(error);
    }

    /**
     * Handles database-related exceptions.
     *
     * @param e the data access exception
     * @return error response with HTTP 500 Internal Server Error
     */
    @ExceptionHandler(DataAccessException.class)
    public ResponseEntity<ErrorResponse> handleDataAccessException(DataAccessException e) {
        log.error("Database error occurred: {}", e.getMessage());
        ErrorResponse error = new ErrorResponse(
                Instant.now().toString(),
                INTERNAL_SERVER_ERROR.value(),
                INTERNAL_SERVER_ERROR.getReasonPhrase(),
                "Internal server error"
        );
        return ResponseEntity.status(INTERNAL_SERVER_ERROR).body(error);
    }

    /**
     * Handles username not found during authentication.
     *
     * @param e the username not found exception
     * @return error response with HTTP 401 Unauthorized
     */
    @ExceptionHandler(UsernameNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUserNotFound(UsernameNotFoundException e) {
        log.error("User not found: {}", e.getMessage());
        ErrorResponse error = new ErrorResponse(
                Instant.now().toString(),
                UNAUTHORIZED.value(),
                UNAUTHORIZED.getReasonPhrase(),
                "Invalid credentials"
        );
        return ResponseEntity.status(UNAUTHORIZED).body(error);
    }

    /**
     * Handles validation errors for incoming request data (triggered by @Valid).
     *
     * @param e the method argument not valid exception
     * @return error response with HTTP 400 Bad Request
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(MethodArgumentNotValidException e) {
        log.error("Invalid request data: {}", e.getMessage());
        ErrorResponse error = new ErrorResponse(
                Instant.now().toString(),
                BAD_REQUEST.value(),
                BAD_REQUEST.getReasonPhrase(),
                "Invalid request data"
        );
        return ResponseEntity.status(BAD_REQUEST).body(error);
    }

    /**
     * Catches all other unhandled exceptions.
     * This is a fallback handler to prevent exposing stack traces to clients.
     *
     * @param e the generic exception
     * @return error response with HTTP 500 Internal Server Error
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception e) {
        log.error("Unexpected error occurred: {}", e.getMessage());
        ErrorResponse error = new ErrorResponse(
                Instant.now().toString(),
                INTERNAL_SERVER_ERROR.value(),
                INTERNAL_SERVER_ERROR.getReasonPhrase(),
                "Unexpected error occurred"
        );
        return ResponseEntity.status(INTERNAL_SERVER_ERROR).body(error);
    }

}

====================
FILE: Message.java

package com.jakubbone.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;

import java.time.LocalDateTime;

@Entity
@Table(name = "messages")
@Getter
@Setter
@NoArgsConstructor
public class Message {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "sender_id", nullable = false)
    private String senderId;

    @Column(name = "recipient_id", nullable = false)
    private String recipientId;

    @Column(nullable = false)
    private String content;

    @CreationTimestamp
    @Column(nullable = false)
    private LocalDateTime timestamp;

    private boolean isRead = false;
}

====================
FILE: MessageRepository.java

package com.jakubbone.repository;

import com.jakubbone.model.Message;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.util.List;

public interface MessageRepository extends JpaRepository<Message, Long> {

    Page<Message> findByRecipientId(String recipientId, Pageable pageable);

    long countByRecipientIdAndIsReadFalse(@Param("recipientId") String recipientId);

    /**
     * Performs bulk update to mark multiple messages as read atomically.
     * Only updates messages that are currently unread.
     *
     * @param messageIds list of message IDs to mark as read
     * @return number of messages updated
     */
    @Modifying
    @Query("UPDATE Message msg SET msg.isRead = true WHERE msg.id IN :messageIds AND msg.isRead = false")
    void markMessagesAsRead(@Param("messageIds") List<Long> messageIds);


    /**
     * Searches messages using PostgreSQL full-text search with ranking.
     * Uses plainto_tsquery for natural language query parsing.
     *
     * @param username the user to search messages for (sender or recipient)
     * @param query the search phrase
     * @param pageable pagination parameters
     * @return page of messages ordered by search relevance
     */
    @Query(value = "SELECT * FROM messages WHERE " +
            "(sender_id = :username OR recipient_id = :username) AND " +
            "search_vector @@ plainto_tsquery('simple', :query) " +
            "ORDER BY ts_rank(search_vector, plainto_tsquery('simple', :query)) DESC", nativeQuery = true)
    Page<Message> searchMessages(@Param("username") String username, @Param("query") String query, Pageable pageable);


}

====================
FILE: AuthService.java

package com.jakubbone.service;

import java.util.Collections;
import java.util.Map;

import com.jakubbone.dto.TokenResponse;
import jakarta.ws.rs.core.Response;
import org.keycloak.representations.idm.CredentialRepresentation;
import org.keycloak.representations.idm.UserRepresentation;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.server.ResponseStatusException;

@Service
public class AuthService {
    @Value("${keycloak.admin-client-id}")
    private String adminClientId;

    @Value("${keycloak.admin-client-secret}")
    private String adminClientSecret;

    @Value("${keycloak.base-url}")
    private String keycloakBaseUrl;

    @Value(("${keycloak.realm}"))
    private String keycloakRealm;

    private final KeycloakUserService keycloakUserService;
    private final RestTemplate restTemplate;

    public AuthService(KeycloakUserService keycloakUserService, RestTemplate restTemplate) {
        this.keycloakUserService = keycloakUserService;
        this.restTemplate = restTemplate;
    }

    public void registerUser(String username, String password,
                               String email, String firstName, String lastName) {
        boolean ifUserExists = keycloakUserService.existsByUsername(username);

        if (ifUserExists) {
            throw new ResponseStatusException(HttpStatus.CONFLICT, "User already exists: " + username);
        }

        UserRepresentation user = new UserRepresentation();
        user.setUsername(username);
        user.setEmail(email);
        user.setFirstName(firstName);
        user.setLastName(lastName);
        user.setEnabled(true);
        user.setEmailVerified(true);

        CredentialRepresentation credential = new CredentialRepresentation();
        credential.setType(CredentialRepresentation.PASSWORD);
        credential.setValue(password);
        credential.setTemporary(false);

        user.setCredentials(Collections.singletonList(credential));

        try (Response response = keycloakUserService.getRealm().users().create(user)) {
            String locationHeader = response.getHeaderString("Location");
            if (locationHeader != null) {
                String userId = locationHeader.substring(locationHeader.lastIndexOf('/') + 1);
                keycloakUserService.assignUserRole(userId);
            }
        }
        catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Registration failed: " + e.getMessage());
        }
    }

    public TokenResponse loginUser(String username, String password){
        String tokenUrl = keycloakBaseUrl + "/realms/" + keycloakRealm + "/protocol/openid-connect/token";

        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("client_id", adminClientId);
        params.add("client_secret", adminClientSecret);
        params.add("grant_type", "password");
        params.add("username", username);
        params.add("password", password);

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

        HttpEntity<MultiValueMap<String, String>> entity = new HttpEntity<>(params, headers);

        try {
            ResponseEntity<Map> response = restTemplate.postForEntity(tokenUrl, entity, Map.class);

            if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {
                String accessToken = (String) response.getBody().get("access_token");
                int expires_in = (int) response.getBody().get("expires_in");
                String tokenType = (String) response.getBody().get("tokenType");

                return new TokenResponse(accessToken, expires_in, tokenType);
            }
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Login failed");
        } catch (HttpClientErrorException.Unauthorized e) {
            throw new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Invalid username or password");
        } catch (HttpClientErrorException e) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Login failed: " + e.getMessage());
        } catch (Exception e) {
            throw new ResponseStatusException(HttpStatus.SERVICE_UNAVAILABLE, "Authentication service unavailable");
        }
    }
}

====================
FILE: KeycloakUserService.java

package com.jakubbone.service;

import lombok.Getter;
import org.keycloak.admin.client.Keycloak;
import org.keycloak.admin.client.resource.RealmResource;
import org.keycloak.representations.idm.RoleRepresentation;
import org.keycloak.representations.idm.UserRepresentation;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.List;

/**
 * Service for interacting with Keycloak to manage users
 */
@Service
@Getter
public class KeycloakUserService {
    @Value("${keycloak.realm}")
    private String keycloakRealm;

    private final Keycloak keycloakAdminClient;

    /**
     * Constructs the service with a configured Keycloak admin client
     *
     * @param keycloakAdminClient Keycloak admin client used to perform operations
     */
    public KeycloakUserService(Keycloak keycloakAdminClient) {
        this.keycloakAdminClient = keycloakAdminClient;
    }

    /**
     * Checks if a user with the given username exists in Keycloak realm.
     *
     * @param username the username to check
     * @return true if user exists, false otherwise
     */
    public boolean existsByUsername(String username) {
        List<UserRepresentation> users = keycloakAdminClient.realm(keycloakRealm).users().searchByUsername(username, true);
        return users != null && !users.isEmpty();
    }

    public void assignUserRole(String userId){
        RoleRepresentation role = getRealm()
                .roles()
                .get("USER")
                .toRepresentation();

        getRealm()
            .users()
            .get(userId)
            .roles()
            .realmLevel()
            .add(Collections.singletonList(role));
    }

    public RealmResource getRealm() {
        return keycloakAdminClient.realm(keycloakRealm);
    }
}

====================
FILE: MessageService.java

package com.jakubbone.service;

import org.owasp.html.PolicyFactory;
import org.owasp.html.Sanitizers;

import com.jakubbone.model.Message;
import com.jakubbone.repository.MessageRepository;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.server.ResponseStatusException;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class MessageService {
    @Value("${mailbox.limit}")
    private int mailboxLimit;

    private final MessageRepository messageRepository;
    private final KeycloakUserService keycloakUserService;
    private final PolicyFactory sanitizer = Sanitizers.FORMATTING.and(Sanitizers.LINKS);

    // Synchronization object to prevent race conditions when checking mailbox limits
    private final Object mailboxLock = new Object();

    public MessageService(MessageRepository messageRepository, KeycloakUserService keycloakUserService) {
        this.messageRepository = messageRepository;
        this.keycloakUserService = keycloakUserService;
    }

    /**
     * Sends a message from one user to another with validation and sanitization.
     * Checks mailbox capacity before sending.
     *
     * @param sender the username of the sender
     * @param recipient the username of the recipient
     * @param content the message content (will be HTML sanitized)
     * @return the saved message entity
     * @throws ResponseStatusException if sending to self (400), recipient not found (404),
     *                                 or mailbox full (409)
     */
    @Transactional
    public Message send(String sender, String recipient, String content) {
        if(recipient.equals(sender)){
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Cannot send message to yourself");
        }

        if (!keycloakUserService.existsByUsername(recipient)) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Invalid recipient:" + recipient);
        }

        synchronized (mailboxLock) {
            long messageCount = messageRepository.countByRecipientIdAndIsReadFalse(recipient);

            if(messageCount >= mailboxLimit){
                throw new ResponseStatusException(HttpStatus.CONFLICT, "Cannot send message: Recipient's mailbox is full");
            }

            // HTML sanitization policy to protect against XSS attacks
            String sanitizedContent = sanitizer.sanitize(content);

            Message msg = new Message();
            msg.setSenderId(sender);
            msg.setRecipientId(recipient);
            msg.setContent(sanitizedContent);
            msg.setTimestamp(LocalDateTime.now());

            return messageRepository.save(msg);
        }
    }

    /**
     * Retrieves paginated messages for a recipient and marks them as read using bulk update.
     * Uses atomic database operation to prevent race conditions.
     *
     * @param recipientId the recipient username
     * @param pageable pagination parameters
     * @return page of messages (updated to read status)
     */
    @Transactional
    public Page<Message> readAndMarkAsRead(String recipientId, Pageable pageable) {
        Page<Message> messages = messageRepository.findByRecipientId(recipientId, pageable);

        if (!messages.isEmpty()) {
            List<Long> unreadMessageIds = messages.getContent().stream()
                    .filter(msg -> !msg.isRead())
                    .map(Message::getId)
                    .toList();

            if (!unreadMessageIds.isEmpty()) {
                // Bulk update (for all messages instantly in DB)
                messageRepository.markMessagesAsRead(unreadMessageIds);

                // Update in-memory messages to reflect DB changes
                messages.getContent().forEach(msg -> {
                    if (unreadMessageIds.contains(msg.getId())) {
                        msg.setRead(true);
                    }
                });
            }
        }

        return messages;
    }

    /**
     * Marks a single message as read for the specified recipient.
     * Verifies that the recipient owns the message before updating.
     *
     * @param id the message ID to mark as read
     * @param recipientId the username of the recipient
     * @throws ResponseStatusException if message not found (404) or access denied (403)
     */
    @Transactional
    public void markAsRead(Long id, String recipientId) {
        Message msg = messageRepository.findById(id).
                orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Resource unavailable"));

        if(!msg.getRecipientId().equals(recipientId)){
            throw new ResponseStatusException(HttpStatus.FORBIDDEN, "Access denied to this message");
        }

        if(!msg.isRead()){
            msg.setRead(true);
            messageRepository.save(msg);
        }
    }

    /**
     * Searches messages using PostgreSQL full-text search.
     * Returns messages where the user is either sender or recipient.
     *
     * @param username the user performing the search
     * @param phrase the search phrase (minimum 2 characters required)
     * @param pageable pagination parameters
     * @return page of messages matching the search phrase, ranked by relevance
     * @throws ResponseStatusException if phrase is too short (400)
     */
    @Transactional
    public Page<Message>searchMessages(String username, String phrase, Pageable pageable){
        if(phrase == null || phrase.trim().length() < 2){
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Query too short");
        }
        return  messageRepository.searchMessages(username, phrase, pageable);
    }
}

====================
FILE: SpringBootMailingApplication.java

package com.jakubbone;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringBootMailingApplication {
	public static void main(String[] args) {
		SpringApplication.run(SpringBootMailingApplication.class, args);
	}
}

====================
FILE: KeycloakRoleConverter.java

package com.jakubbone.utils;

import org.springframework.core.convert.converter.Converter;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.oauth2.jwt.Jwt;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Converts a JWT token from Keycloak to a collection of Spring Security granted authorities
 */
public class KeycloakRoleConverter implements Converter<Jwt, Collection<GrantedAuthority>> {
    /**
     * Converts the given JWT by extracting roles from the "realm_access" claim
     * If no roles are found, returns an empty collection
     *
     * @param jwt the JWT token to convert
     * @return collection of granted authorities with "ROLE_" prefix
     */
    @Override
    public Collection<GrantedAuthority> convert(Jwt jwt) {
        Map<String, Object> realmAccess = (Map<String, Object>) jwt.getClaims().get("realm_access");
        if (realmAccess == null || realmAccess.isEmpty()) {
            return Collections.emptyList();
        }
        List<String> roles = (List<String>) realmAccess.get("roles");
        if (roles == null) return Collections.emptyList();

        return roles.stream()
                .map(role -> "ROLE_" + role)
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}

====================
FILE: ActuatorTest.java

package com.jakubbone.integration;

import com.jakubbone.integration.common.AbstractIntegrationTest;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.http.MediaType;
import org.springframework.security.test.context.support.WithMockUser;

import org.springframework.test.web.servlet.MockMvc;

import static org.hamcrest.Matchers.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;


/**
 * Integration tests for Spring Boot Actuator endpoints security configuration.
 *
 * NOTE: These tests use @WithMockUser instead of real JWT tokens due to JWT token
 * validation failures in CI/CD environments. The Keycloak TestContainer may have
 * different network configuration or timing issues that prevent proper token
 * generation/validation, causing all authenticated requests to return 401 instead
 * of expected 200/403 status codes.
 *
 * This approach tests Spring Security authorization rules but not the complete
 * OAuth2/JWT token validation flow.
 *
 * For full JWT flow testing, run MessageTest which includes real Keycloak integration.
 */
@AutoConfigureMockMvc
class ActuatorTest extends AbstractIntegrationTest {

    @Autowired MockMvc mockMvc;

    // Public endpoints - no authentication required

    @Test
    void shouldReturnActuatorHealth_withoutAuth() throws Exception {
        mockMvc.perform(get("/actuator/health"))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.parseMediaType(
                        "application/vnd.spring-boot.actuator.v3+json")))
                .andExpect(jsonPath("$.status").value("UP"));
    }

    @Test
    void shouldReturnApplicationInfo_withoutAuth() throws Exception {
        mockMvc.perform(get("/actuator/info"))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.parseMediaType(
                        "application/vnd.spring-boot.actuator.v3+json")))
                .andExpect(jsonPath("$.app.name").value("SpringBootMailingSystem"))
                .andExpect(jsonPath("$.app.version").value("0.0.1-SNAPSHOT"));
    }

    // Protected endpoints - ADMIN role tests

    @Test
    @WithMockUser(roles = "ADMIN")
    void shouldReturnUptimeMetric_whenAdminAuthenticated() throws Exception {
        mockMvc.perform(get("/actuator/metrics/process.uptime"))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.parseMediaType(
                        "application/vnd.spring-boot.actuator.v3+json")))
                .andExpect(jsonPath("$.name").value("process.uptime"))
                .andExpect(jsonPath("$.measurements", hasSize(greaterThan(0))))
                .andExpect(jsonPath("$.measurements[0].value", greaterThanOrEqualTo(0.0)));
    }

    @Test
    @WithMockUser(roles = "ADMIN")
    void shouldReturnAvailableEndpoints_whenAdminAuthenticated() throws Exception {
        mockMvc.perform(get("/actuator"))
                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(content().contentType(MediaType.parseMediaType(
                        "application/vnd.spring-boot.actuator.v3+json")))
                .andExpect(jsonPath("$._links.self").exists())
                .andExpect(jsonPath("$._links.health").exists())
                .andExpect(jsonPath("$._links.info").exists())
                .andExpect(jsonPath("$._links.metrics").exists());
    }

    // USER role tests - should get 403 Forbidden

    @Test
    @WithMockUser(roles = "USER")
    void shouldReturn403_whenUserTriesToAccessMetrics() throws Exception {
        mockMvc.perform(get("/actuator/metrics/process.uptime"))
                .andDo(print())
                .andExpect(status().isForbidden()); // USER role can't access metrics
    }

    @Test
    @WithMockUser(roles = "USER")
    void shouldReturn403_whenUserAccessesRootActuator() throws Exception {
        mockMvc.perform(get("/actuator"))
                .andDo(print())
                .andExpect(status().isForbidden());
    }

    @Test
    @WithMockUser(roles = "USER")
    void shouldReturn403_whenUserTriesToShutdown() throws Exception {
        mockMvc.perform(post("/actuator/shutdown"))
                .andDo(print())
                .andExpect(status().isForbidden()); // USER can't shutdown
    }

    // No authentication tests - should get 401 Unauthorized

    @Test
    void shouldReturn401_whenAccessingMetricsWithoutAuth() throws Exception {
        mockMvc.perform(get("/actuator/metrics/process.uptime"))
                .andDo(print())
                .andExpect(status().isUnauthorized()); // No token = 401
    }

    @Test
    void shouldReturn401_whenAccessingRootActuatorWithoutAuth() throws Exception {
        mockMvc.perform(get("/actuator"))
                .andDo(print())
                .andExpect(status().isUnauthorized());
    }

    @Test
    void shouldReturn401_whenShutdownWithoutAuth() throws Exception {
        mockMvc.perform(post("/actuator/shutdown"))
                .andDo(print())
                .andExpect(status().isUnauthorized()); // No token = 401
    }
}

====================
FILE: AuthTest.java

package com.jakubbone.integration;

import static org.junit.Assert.assertEquals;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import java.util.List;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.jakubbone.dto.LoginRequest;
import com.jakubbone.dto.RegisterRequest;
import com.jakubbone.integration.common.AbstractIntegrationTest;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.keycloak.admin.client.Keycloak;
import org.keycloak.representations.idm.UserRepresentation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.result.MockMvcResultHandlers;

@AutoConfigureMockMvc
class AuthTest extends AbstractIntegrationTest {
    @Autowired
    MockMvc mockMvc;

    @Autowired
    ObjectMapper mapper;

    @Autowired
    Keycloak keycloakAdminClient;

    @BeforeEach()
    void setup(){
        cleanupTestUsers("testuser");
    }

    private void cleanupTestUsers(String username) {
        try {
            List<UserRepresentation> user = keycloakAdminClient
                    .realm("test")
                    .users()
                    .searchByUsername(username, true);

            keycloakAdminClient.realm("test").users().delete(username);
        } catch (Exception e) {
            // Ignore -> user could not exist
        }
    }

    RegisterRequest createRegisterRequest(String username, String email, String password,
                                                  String firstName, String lastName) {
        return new RegisterRequest(
                username,
                password,
                email,
                firstName,
                lastName
        );
    }

    LoginRequest createLoginRequest(String username, String password){
        return new LoginRequest(
                username,
                password
        );
    }

    // Registration

    @Test
    void shouldReturn201_whenRegisterValidUser() throws Exception {
        RegisterRequest req = createRegisterRequest(
                "newuser",
                "newuser@spring.com",
                "Password123!",
                "new",
                "user"
        );

        // Register user
        mockMvc.perform(post("/api/v1/auth/register")
                .contentType(MediaType.APPLICATION_JSON)
                .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isCreated());

        // Verify user exists in Keycloak
        List<UserRepresentation> users = keycloakAdminClient
                .realm("test")
                .users()
                .searchByUsername("newuser", true);

        assertEquals("newuser", users.get(0).getUsername());
        assertEquals("newuser@spring.com", users.get(0).getEmail());
    }

    @Test
    void shouldReturn201_whenRegisterExistingUser() throws Exception {
        RegisterRequest req1 = createRegisterRequest(
                "duplicate",
                "first@example.com",
                "Password123!",
                "First",
                "User"
        );

        // First registration
        mockMvc.perform(post("/api/v1/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req1)))
                .andExpect(status().isCreated());

        // Try to register with same username
        RegisterRequest req2 = createRegisterRequest(
                "duplicate",  // Same username
                "second@example.com",
                "Password123!",
                "Second",
                "User"
        );

        // Second registration
        mockMvc.perform(post("/api/v1/auth/register")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req2)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isConflict());

        // Cleanup
        cleanupTestUsers("duplicate");
    }

    // Login tests

    @Test
    void shouldReturn200AndAccessToken_whenLoginValidCredentials() throws Exception {
        LoginRequest req = createLoginRequest("testuser", "userPassword");

        mockMvc.perform(post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.accessToken").isString())
                .andExpect(jsonPath("$.accessToken").isNotEmpty())
                .andExpect(jsonPath("$.expireTime").isNumber());
    }

    @Test
    void shouldReturn200AndAccessToken_whenLoginAdminValidCredentials() throws Exception {
        LoginRequest req = createLoginRequest("testadmin", "adminPassword");

        mockMvc.perform(post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.accessToken").isString())
                .andExpect(jsonPath("$.accessToken").isNotEmpty())
                .andExpect(jsonPath("$.expireTime").isNumber());
    }

    @Test
    void shouldReturn401_whenInvalidUsername() throws Exception {
        LoginRequest req = createLoginRequest("nonexistent", "anyPassword");

        mockMvc.perform(post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.message").value("Invalid username or password"));
    }

    @Test
    void shouldReturn401_whenInvalidPassword() throws Exception {
        LoginRequest req = createLoginRequest("testuser", "wrongPassword");

        mockMvc.perform(post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isUnauthorized())
                .andExpect(jsonPath("$.message").value("Invalid username or password"));
    }

    @Test
    void shouldReturn400_whenUsernameIsBlank() throws Exception {
        LoginRequest req = createLoginRequest("", "Password123");

        mockMvc.perform(post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value("Invalid request data"));
    }

    @Test
    void shouldReturn400_whenPasswordIsBlank() throws Exception {
        LoginRequest req = createLoginRequest("testuser", "");

        mockMvc.perform(post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value("Invalid request data"));
    }

    @Test
    void shouldReturn400_whenUsernameIsNull() throws Exception {
        LoginRequest req = new LoginRequest();
        req.setPassword("Password123!");

        mockMvc.perform(post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isBadRequest());
    }

    @Test
    void shouldReturn400_whenPasswordIsNull() throws Exception {
        LoginRequest req = new LoginRequest();
        req.setUsername("testuser");

        mockMvc.perform(post("/api/v1/auth/login")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isBadRequest());
    }
}

====================
FILE: AbstractIntegrationTest.java

package com.jakubbone.integration.common;

import dasniko.testcontainers.keycloak.KeycloakContainer;
import org.junit.jupiter.api.BeforeAll;
import org.keycloak.OAuth2Constants;
import org.keycloak.admin.client.Keycloak;
import org.keycloak.admin.client.KeycloakBuilder;
import org.keycloak.representations.idm.CredentialRepresentation;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.Network;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.containers.wait.strategy.Wait;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.time.Duration;

@Testcontainers
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_CLASS)
public abstract class AbstractIntegrationTest {
    // Shared Network in order to avoid MessageTest and ActuatorTest collision
    private static final Network NET = Network.SHARED;

    @Container
    private static final PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15-alpine")
            .withNetwork(NET)
            .withNetworkAliases("postgres")
            .withUsername("testuser")
            .withPassword("testpass")
            .withDatabaseName("testdb");

    @Container
    private static final KeycloakContainer keycloak = new KeycloakContainer("quay.io/keycloak/keycloak:26.2.4")
            .withNetwork(NET)
            .withNetworkAliases("keycloak")
            .withRealmImportFile("test-realm.json") // From classpath
            .withEnv("KC_FEATURES", "token-exchange")
            .withEnv("KC_FEATURES", "impersonation")
            .withEnv("KC_DB", "postgres")
            .withEnv("KC_DB_URL_HOST", "postgres")
            .withEnv("KC_DB_URL_DATABASE", postgres.getDatabaseName())
            .withEnv("KC_DB_USERNAME", postgres.getUsername())
            .withEnv("KC_DB_PASSWORD", postgres.getPassword())
            .withEnv("KC_PROXY", "edge")
            .withAdminUsername("admin")
            .withAdminPassword("admin")
            .dependsOn(postgres)
            .waitingFor(Wait.forHttp("/realms/test")
                    .forStatusCode(200)
                    .withStartupTimeout(Duration.ofMinutes(2)));
                    // act as healthcheck

    @DynamicPropertySource
    static void dynamicProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
        registry.add("spring.flyway.enabled", () -> "false");

        String authServerUrl = keycloak.getAuthServerUrl();
        String issuerUri = authServerUrl + "/realms/test";

        registry.add("keycloak.base-url", () -> authServerUrl);
        registry.add("keycloak.realm", () -> "test");
        registry.add("keycloak.admin-client-id", () -> "test-client-id");
        registry.add("keycloak.admin-client-secret", () -> "1234");

        registry.add("spring.security.oauth2.resourceserver.jwt.issuer-uri", () -> issuerUri);
        registry.add("spring.security.oauth2.resourceserver.jwt.jwk-set-uri", () -> issuerUri + "/protocol/openid-connect/certs");
    }

    @BeforeAll
    static void setupKeycloakUsers() {
        Keycloak adminClient = KeycloakBuilder.builder()
                .serverUrl(keycloak.getAuthServerUrl())
                .realm("master")
                .clientId("admin-cli")
                .username("admin")
                .password("admin")
                .build();

        // Reset password because Keycloak stores it as a hash
        resetUserPassword(adminClient, "a7d68651-6850-4fee-94d0-836c11117754", "adminPassword"); // 'admin'
        resetUserPassword(adminClient, "587244a1-e624-4511-8d8b-e4e851940295", "userPassword"); // 'testuser'
    }

    private static void resetUserPassword(Keycloak adminClient, String userId, String password) {
        CredentialRepresentation passwordCred = new CredentialRepresentation();
        passwordCred.setTemporary(false);
        passwordCred.setType(CredentialRepresentation.PASSWORD);
        passwordCred.setValue(password);
        adminClient.realm("test").users().get(userId).resetPassword(passwordCred);
    }

    protected String getJwtToken(String username, String password) {
        Keycloak keycloakClient = KeycloakBuilder.builder()
                .serverUrl(keycloak.getAuthServerUrl())
                .realm("test")
                .clientId("test-client-id")
                .clientSecret("1234")
                .username(username)
                .password(password)
                .grantType(OAuth2Constants.PASSWORD)
                .build();
        return keycloakClient.tokenManager().getAccessToken().getToken();
    }

}

====================
FILE: MessageTest.java

package com.jakubbone.integration;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.jakubbone.integration.common.AbstractIntegrationTest;
import com.jakubbone.dto.SendMessageRequest;
import com.jakubbone.repository.MessageRepository;
import org.junit.Assert;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.result.MockMvcResultHandlers;
import org.springframework.transaction.annotation.Transactional;

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.patch;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

@AutoConfigureMockMvc
class MessageTest extends AbstractIntegrationTest {
    String user = "testuser";
    String admin = "testadmin";

    @Value("${mailbox.limit}")
    int mailboxLimit = 5;

    @Autowired
    MockMvc mockMvc;

    @Autowired
    ObjectMapper mapper;

    @Autowired
    MessageRepository messageRepository;

    @Autowired
    JdbcTemplate jdbcTemplate;

    String adminToken;
    String userToken;

    @BeforeEach
    void setup() {
        messageRepository.deleteAll();
        jdbcTemplate.execute("ALTER TABLE messages ALTER COLUMN id RESTART WITH 1");
        jdbcTemplate.execute("ALTER TABLE messages ADD COLUMN IF NOT EXISTS search_vector tsvector GENERATED ALWAYS AS (to_tsvector('simple', content)) STORED");
        jdbcTemplate.execute("CREATE INDEX IF NOT EXISTS idx_messages_search_vector ON messages USING GIN (search_vector)");
        adminToken = getJwtToken(admin, "adminPassword");
        userToken = getJwtToken(user, "userPassword");
    }

    private SendMessageRequest createMessageRequest(String recipient, String content) {
        return new SendMessageRequest(recipient, content);
    }

    @Test
    void shouldReturn201_andSentMessage_whenAdminSendsValidMessage() throws Exception {
        SendMessageRequest req = createMessageRequest(user, "Hello testuser!");

        mockMvc.perform(post("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isCreated());
    }

    @Test
    void shouldReturn201_andSentMessage_whenUserSendsValidMessage() throws Exception {
        SendMessageRequest req = createMessageRequest(admin, "Hello testadmin!");

        mockMvc.perform(post("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + userToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isCreated());
    }

    @Test
    void shouldReturn404_whenRecipientNotFound() throws Exception {
        SendMessageRequest req = createMessageRequest("unknown", "Hello user!");

        mockMvc.perform(post("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + userToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isNotFound());
    }

    @Test
    void shouldReturn400_whenRecipientUsernameInvalid() throws Exception {
        // Username too short
        SendMessageRequest req = createMessageRequest("ab", "Hello user!");
        mockMvc.perform(post("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andExpect(status().isBadRequest());

        // Username too long
        req = createMessageRequest("verylongusername", "Hello user!");
        mockMvc.perform(post("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andExpect(status().isBadRequest());

        // Username with special characters
        req = createMessageRequest("user123", "Hello user!");
        mockMvc.perform(post("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andExpect(status().isBadRequest());
    }

    @Test
    void shouldReturn400_whenMessageTooLong() throws Exception {
        String longMessage = "a".repeat(257); // Exceed the 256 character limit
        SendMessageRequest req = createMessageRequest(user, longMessage);

        mockMvc.perform(post("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andExpect(status().isBadRequest());
    }

    @Test
    void shouldReturn400_whenSendingMessageToSelf() throws Exception {
        SendMessageRequest req = createMessageRequest(admin, "Hello myself!");

        mockMvc.perform(post("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value("Cannot send message to yourself"));
    }

    @Test
    void shouldSanitizeHtmlContent_whenSendingMessage() throws Exception {
        String htmlContent = "Hello <script>alert('xss')</script> <b>bold</b> world!";
        SendMessageRequest req = createMessageRequest(user, htmlContent);

        mockMvc.perform(post("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.content").value("Hello  <b>bold</b> world!")); // script usunięty
    }

    @Test
    void shouldReturn403_whenTryingToReadOtherUsersMessage() throws Exception {
        SendMessageRequest req = createMessageRequest(user, "Hello testuser!");
        mockMvc.perform(post("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andExpect(status().isCreated());

        mockMvc.perform(patch("/api/v1/messages/1/read")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken))
                .andExpect(status().isForbidden())
                .andExpect(jsonPath("$.message").value("Access denied to this message"));
    }

    @Test
    void shouldReturn404_whenMarkingNonExistentMessageAsRead() throws Exception {
        mockMvc.perform(patch("/api/v1/messages/999/read")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + userToken))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.message").value("Resource unavailable"));
    }

    @Test
    void shouldReturn404_whenNoContent() throws Exception {
        SendMessageRequest req = createMessageRequest(admin, "");

        mockMvc.perform(post("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + userToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isBadRequest());
    }

    @Test
    void shouldReturn409_whenMailboxFull() throws Exception {
        SendMessageRequest req = createMessageRequest(user, "Hello testuser!");

        // Send maximum number of messages
        for(int i = 0; i < mailboxLimit; i++){
            mockMvc.perform(post("/api/v1/messages")
                            .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(mapper.writeValueAsBytes(req)))
                    .andDo(MockMvcResultHandlers.print())
                    .andExpect(status().isCreated());
        }

        // Send one more message when mailbox overloaded
        mockMvc.perform(post("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isConflict());
    }

    @Test
    void shouldReturn409_whenUnauthorized() throws Exception {
        SendMessageRequest req = createMessageRequest(user, "Hello testuser!");

        for(int i = 0; i < mailboxLimit; i++){
            mockMvc.perform(post("/api/v1/messages")
                            .header(HttpHeaders.AUTHORIZATION, "Bearer " + "unknown")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(mapper.writeValueAsBytes(req)))
                    .andDo(MockMvcResultHandlers.print())
                    .andExpect(status().isUnauthorized());
        }
    }

    @Test
    @Transactional
    // The service method countByRecipientIdAndIsReadFalse() call needs the annotation @Transactional
    void shouldReturnTrue_whenMessagesMarkedAsRead() throws Exception {
        SendMessageRequest req = createMessageRequest("testuser", "Hello testuser!");

        // Send by admin
        for(int i = 0; i < 3; i++){
            mockMvc.perform(post("/api/v1/messages")
                            .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(mapper.writeValueAsBytes(req)))
                    .andDo(MockMvcResultHandlers.print())
                    .andExpect(status().isCreated());
        }

        // Read by user
        for(int i = 1; i <= 3; i++){
            mockMvc.perform(patch("/api/v1/messages/" + i + "/read")
                            .header(HttpHeaders.AUTHORIZATION, "Bearer " + userToken))
                    .andDo(MockMvcResultHandlers.print())
                    .andExpect(status().isNoContent());
        }

        long unread = messageRepository.countByRecipientIdAndIsReadFalse("testuser");
        Assert.assertEquals(0, unread);
    }

    @Test
    void shouldReturnCorrectPage_whenPaginatingMessages() throws Exception {
        for(int i = 1; i <= 4; i++) {
            SendMessageRequest req = createMessageRequest(user, "Message " + i);
            mockMvc.perform(post("/api/v1/messages")
                            .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                            .contentType(MediaType.APPLICATION_JSON)
                            .content(mapper.writeValueAsBytes(req)))
                    .andExpect(status().isCreated());
        }

        mockMvc.perform(get("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + userToken)
                        .param("page", "0")
                        .param("size", "2"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.totalElements").value(4))
                .andExpect(jsonPath("$.numberOfElements").value(2))
                .andExpect(jsonPath("$.totalPages").value(2))
                .andExpect(jsonPath("$.first").value(true))
                .andExpect(jsonPath("$.last").value(false));

        mockMvc.perform(get("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + userToken)
                        .param("page", "1")
                        .param("size", "2"))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.numberOfElements").value(2))
                .andExpect(jsonPath("$.first").value(false))
                .andExpect(jsonPath("$.last").value(true));
    }

    // Searching test: edge cases
    @Test
    void shouldReturn400_whenSearchPhraseIsEmpty() throws Exception {
        mockMvc.perform(get("/api/v1/messages/search")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + userToken)
                        .param("phrase", ""))
                .andExpect(status().isBadRequest());
    }

    @Test
    void shouldReturn400_whenSearchPhraseIsWhitespace() throws Exception {
        mockMvc.perform(get("/api/v1/messages/search")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + userToken)
                        .param("phrase", "   "))
                .andExpect(status().isBadRequest());
    }

    @Test
    void shouldReturn200_andEmptyPageOfMessages_whenRecipientNoHasMessages() throws Exception {
        mockMvc.perform(get("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + userToken))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.totalElements").value(0))
                .andExpect(jsonPath("$.numberOfElements").value(0))
                .andExpect(jsonPath("$.totalPages").value(0));
    }

    @Test
    void shouldReturn404_whenExpiredOrInvalid() throws Exception {
        mockMvc.perform(get("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + "invalid"))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isUnauthorized());
    }

    @Test
    void shouldReturn401_whenNoAuthorizationHeader() throws Exception {
        SendMessageRequest req = createMessageRequest(user, "Hello testuser!");

        mockMvc.perform(post("/api/v1/messages")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andExpect(status().isUnauthorized());
    }

    @Test
    void shouldReturn200_andPageOfMessages_whenSearchingForMessages() throws Exception {
        SendMessageRequest req = createMessageRequest(admin, "Hello testadmin!");

        // Send by user
        mockMvc.perform(post("/api/v1/messages")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + userToken)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(mapper.writeValueAsBytes(req)))
                .andExpect(status().isCreated());

        // Search by user
        mockMvc.perform(get("/api/v1/messages/search")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + userToken)
                        .param("phrase", "testadmin"))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.totalElements").value(1))
                .andExpect(jsonPath("$.content[0].content").value("Hello testadmin!"));

        // Search by admin
        mockMvc.perform(get("/api/v1/messages/search")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + adminToken)
                        .param("phrase", "testadmin"))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.totalElements").value(1));
    }

    @Test
    void shouldReturn400_whenSearchPhraseIsTooShort() throws Exception {
        mockMvc.perform(get("/api/v1/messages/search")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + userToken)
                        .param("phrase", "a"))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isBadRequest());
    }

    @Test
    void shouldReturn200_andEmptyPage_whenNoMessagesFound() throws Exception {
        mockMvc.perform(get("/api/v1/messages/search")
                        .header(HttpHeaders.AUTHORIZATION, "Bearer " + userToken)
                        .param("phrase", "nonexistent"))
                .andDo(MockMvcResultHandlers.print())
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.totalElements").value(0));
    }
}




====================
FILE: KeycloakUserServiceTest.java

package com.jakubbone.unit;

import com.jakubbone.service.KeycloakUserService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.keycloak.admin.client.Keycloak;
import org.keycloak.admin.client.resource.RealmResource;
import org.keycloak.admin.client.resource.UsersResource;
import org.keycloak.representations.idm.UserRepresentation;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class KeycloakUserServiceTest {
    @Mock
    Keycloak keycloakAdminClient;

    @InjectMocks
    KeycloakUserService keycloakUserService;

    @Mock
    RealmResource realmResource;

    @Mock
    UsersResource usersResource;

    @BeforeEach
    void setup(){
        ReflectionTestUtils.setField(keycloakUserService, "keycloakRealm", "testRealm");
    }

    @Test
    void shouldReturnTrue_WhenUserExists(){
        String username = "testuser";
        List<UserRepresentation> users = Arrays.asList(new UserRepresentation());


        when(keycloakAdminClient.realm("testRealm")).thenReturn(realmResource);
        when(keycloakAdminClient.realm("testRealm").users()).thenReturn(usersResource);
        when(keycloakAdminClient.realm("testRealm").users().searchByUsername(username,true)).thenReturn(users);

        boolean exists = keycloakUserService.existsByUsername(username);

        assertTrue(exists);
    }

    @Test
    void shouldReturnTrue_WhenUserDoesNotExist(){
        String username = "nonexistent";
        List<UserRepresentation> users = Collections.emptyList();

        when(keycloakAdminClient.realm("testRealm")).thenReturn(realmResource);
        when(keycloakAdminClient.realm("testRealm").users()).thenReturn(usersResource);
        when(keycloakAdminClient.realm("testRealm").users().searchByUsername(username,true)).thenReturn(users);

        boolean exists = keycloakUserService.existsByUsername(username);

        assertFalse(exists);
    }

    @Test
    void shouldReturnFalse_whenSearchReturnsNull() {
        String username = "testuser";

        when(keycloakAdminClient.realm("testRealm")).thenReturn(realmResource);
        when(realmResource.users()).thenReturn(usersResource);
        when(usersResource.searchByUsername(username, true)).thenReturn(null);

        boolean exists = keycloakUserService.existsByUsername(username);

        assertFalse(exists);
    }
}

====================
FILE: MessageServiceTest.java

package com.jakubbone.unit;

import com.jakubbone.model.Message;
import com.jakubbone.repository.MessageRepository;
import com.jakubbone.service.KeycloakUserService;
import com.jakubbone.service.MessageService;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.web.server.ResponseStatusException;


import java.util.Optional;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
class MessageServiceTest {
    @Mock
    MessageRepository messageRepository;

    @Mock
    KeycloakUserService keycloakUserService;

    @InjectMocks
    MessageService messageService;

    @Test
    void shouldThrowException_whenSendingToSelf() {
        String sender = "testuser";
        String recipient = "testuser";
        String content = "Hello";

        ResponseStatusException ex = assertThrows(
                ResponseStatusException.class,
                () -> messageService.send(sender, recipient, content)
        );

        assertEquals("Cannot send message to yourself", ex.getReason());
        assertEquals(HttpStatus.BAD_REQUEST, ex.getStatusCode());
    }

    @Test
    void shouldThrowException_whenMailboxFull() {
        ReflectionTestUtils.setField(messageService, "mailboxLimit", 5);

        String sender = "testuser";
        String recipient = "recipient";
        String content = "Hello";

        when(keycloakUserService.existsByUsername(recipient)).thenReturn(true);
        when(messageRepository.countByRecipientIdAndIsReadFalse(recipient)).thenReturn(5L);

        ResponseStatusException ex = assertThrows(
                ResponseStatusException.class,
                () -> messageService.send(sender, recipient, content)
        );

        assertEquals("Cannot send message: Recipient's mailbox is full", ex.getReason());
        assertEquals(HttpStatus.CONFLICT, ex.getStatusCode());
    }

    @Test
    void shouldSanitizeContent_whenSendingMessage() {
        ReflectionTestUtils.setField(messageService, "mailboxLimit", 5);

        String sender = "testuser";
        String recipient = "recipient";
        String content = "Hello <script>alert('XSS')</script> <b>world</b>";

        when(keycloakUserService.existsByUsername(recipient)).thenReturn(true);
        when(messageRepository.countByRecipientIdAndIsReadFalse(recipient)).thenReturn(1L);
        when(messageRepository.save(any(Message.class))).thenAnswer(i -> i.getArguments()[0]);

        Message msg = messageService.send(sender, recipient, content);

        assertFalse(msg.getContent().contains("<script>"));
        assertTrue(msg.getContent().contains("<b>world</b>"));
    }

    @Test
    void shouldThrowException_whenMarkingNotExistentMessage() {
        ReflectionTestUtils.setField(messageService, "mailboxLimit", 5);

        long messageId = 1L;
        String recipient = "recipient";

        when(messageRepository.findById(messageId)).thenReturn(Optional.empty());

        ResponseStatusException ex = assertThrows(
                ResponseStatusException.class,
                () -> messageService.markAsRead(messageId, recipient)
        );

        assertEquals(HttpStatus.NOT_FOUND, ex.getStatusCode());
    }

    @Test
    void shouldThrowException_whenMarkingOtherUser() {
        ReflectionTestUtils.setField(messageService, "mailboxLimit", 5);

        long messageId = 1L;
        String recipient = "testuser";
        Message msg = new Message();
        msg.setRecipientId("otheruser");

        when(messageRepository.findById(messageId)).thenReturn(Optional.of(msg));



        ResponseStatusException ex = assertThrows(
                        ResponseStatusException.class,
                () -> messageService.markAsRead(messageId, recipient)
        );

        assertEquals(HttpStatus.FORBIDDEN, ex.getStatusCode());
    }

    @Test
    void shouldThrowException_whenSearchPhraseEmpty() {
        ResponseStatusException ex = assertThrows(
                ResponseStatusException.class,
                () -> messageService.searchMessages("testuser", "", Pageable.unpaged())
        );

        assertEquals(HttpStatus.BAD_REQUEST, ex.getStatusCode());
        assertEquals("Query too short", ex.getReason());
    }

    @Test
    void shouldThrowException_whenSearchPhraseTooShort() {
        ResponseStatusException ex = assertThrows(
                ResponseStatusException.class,
                () -> messageService.searchMessages("testuser", "a", Pageable.unpaged())
        );

        assertEquals(HttpStatus.BAD_REQUEST, ex.getStatusCode());
    }
}

